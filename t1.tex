%!TEX root = desc.tex

%thrust1
\subsection{Thrust 1: Polymorphism-Enabled Features}
\label{sec:t1}

The first thrust of this work will design new features for choreographic languages
that rely on first-class process polymorphism and
are needed to substantially broaden the range of possible choreographic applications.

\subsubsection{Spawning New Locations}
\label{sec:spawning}

The first feature is the ability to spawn and kill new locations---computational units representing threads, processes, nodes, etc---% DO NOT DELETE, COMMENT IS IMPORTANT FOR SPACING
a core feature of many concurrent systems.
A few early choreographic works recognized its importance~\citep{CarboneM13,CruzFilipeM16a},
but those works lacked critical features for realistic programming, like higher-order operations,
and required locations to be spawned only to execute specific pre-defined operations.

We propose a much more general structure, where there is little distinction between an existing location and a newly-spawned one,
and threads may be killed when they are no longer needed.
Moreover, we will integrate this dynamic location management with a host of modern choreographic advances,
including higher-order functions and process polymorphism.

\begin{example}{Dynamic Thread Pool}
Many systems incorporate thread pools that dynamically resize based on demand.
That is, at high-demand times when requests are regularly waiting on threads, they spawn more,
and at low-demand times when threads are regularly sitting idle, excess threads are killed.
The proposed work would allow us to implement such thread pools as choreographies
with code akin to the following.
\[
  \text{\ethan{Thread pool example code.}}
\]

The PIs recent work on first-class location polymorphism showed how to
implement \emph{static} thread pools with a fixed set of threads~\citep{SamuelsonHC25}.
However, that work assumes the set of threads in the entire system is fixed,
inherently preventing dynamically resizing the thread pool.
\end{example}

Safely spawning and killing locations in a choreography---be they threads, processes, or entire nodes---poses three distinct problems,
all illustrated by the above example.
\begin{enumerate}
  \item\label{spawn:li:name}
    Existing locations must be made aware of the new one in a way that allows them to interact with it.
    Otherwise the new location cannot send or receive messages, meaning they cannot participate in the choreography in any meaningful way.

    \textit{Example:} Clients of newly-spawned threads must know where to send their jobs.
  \item\label{spawn:li:code}
    The new location must know what code to execute, and it must match the code existing nodes expect.
    Without the correct code, the new location and existing locations might not have matching message sends and receives, causing deadlock.

    \textit{Example:} New threads must know to wait for instructions from a client and execute them
    and reply with the result, or the client will deadlock.
  \item\label{spawn:li:kill}
    If a location is killed, living locations must know not to send to or receive from the terminated location.
    A retained reference to a dead name can result in a live location attempting to contact a dead one, producing deadlock.

    \textit{Example:} The pool manager and clients must properly discard all references to a killed thread.
\end{enumerate}

The first concern is solved immediately by first-class location polymorphism.
Upon spawning a new thread, we give it a new name and bind that name to a location variable.
That location now functions just as any other polymorphic location variable;
it can be transmitted across the network or used as an endpoint for sending and receiving messages.

Problems~\ref{spawn:li:code} and~\ref{spawn:li:kill}---both of which can cause deadlock if not properly addressed---require additional research.
We propose two complementary strategies to addressing these concerns and retaining deadlock freedom with spawned locations:
scoped locations, and fractional permission tracking.

\paragraph{Preliminary Work: Scoped Locations}
Preliminary work conducted by both PIs and PI Cecchetti's graduate student
has shown that confining the lifetime of spawned locations to a syntactic scope in the choreography is a viable approach.
In the thread pool example, if there are too many requests, the pool manager could easily spawn a new thread
to process an individual request and that thread would automatically die after processing is complete.
The code for this case might look as follows where~$F$ is a local thunk provided by the client~$\Client$
specifying the computation to run.
\[
  \addtocounter{numlevels}{1}
  \ForkIn{\Mngr}{T \ColSend \Client}{%
    \LetMany{{T.f}{F \ColSend W}{\Client.\mathit{res}}{T.(f~()) \ColSend \Client}}
            {\Client.\mathit{res}}
  }
  \addtocounter{numlevels}{-1}
\]
This code specifies that the pool manager~$\Mngr$ forks a new thread,
binds the name of that thread to~$T$, and sends it to the client~$\Client$.
The client then sends its job to the thread who runs it and passes the result back to the client.

Scoping the lifetime of~$T$ makes it very easy to know what code it needs:
the $T$-projection of the body of the~\ForkN block.
Ensuring that~$T$ is only referenced while it is alive is more complicated.
While the scoping provides a syntactic boundary for when such a reference is safe,
it does not automatically guarantee that no thread can attempt to reference~$T$ after it dies.
Consider the following choreography that forks a process and returns a function closing over its name: $\ForkIn{\Alice}{T}{\LamN \_\ldotp \Alice.42 \ColSend T}$.
This function, if applied, would immediately cause deadlock, as~\Alice attempts to send~$42$ to a thread that is no longer alive.

Instead, our preliminary work indicates that we can resolve this dilemma by tracking the locations involved in a function
and verifying that any function returned from a~\ForkN block does not reference the spawned location.
Specifically, augmenting function types with the set of locations needed to compute the function
allows the typing rule for~\ForkN to verify that those locations are all in scope---and thus alive---outside the~\ForkN block.

As part of the proposed work, we will complete this preliminary work, including providing a proof deadlock freedom
and a variety of practical examples.

\ethan{Do we need a goal here? It really feels like ``just write the paper we submitted to POPL.''}

%\ethan{%
%\begin{outline}{Scoped Locations}
%  \item Lifetime of new location defined by syntactic scope of \ForkN.
%  \item Makes clear what code to send to the new location (everything in the scope where it is alive).
%  \item Clear boundary for where the location can be referenced.
%  \item Still need to stop spawned location names from leaking out of the scope (e.g., inside closures).
%    \begin{lvl}
%      \item Track who is involved in the types.
%      \item Involved-location check of return types at the scope boundary.
%    \end{lvl}
%\end{outline}
%}

\paragraph{Proposed Work: Fractional Permission Tracking}
The scoped-based process forking described above allows for any application that spawns new locations to handle individual tasks.
While many such applications exist---making it a powerful addition to the choreographic toolbox---% DO NOT DELETE, COMMENT IS IMPORTANT FOR SPACING
some systems require dynamic locations with indefinite lifetimes.
For example, the thread pool may not wish to spawn additional threads only for a single task,
but instead simply increase the pool capacity when demand is high
and be willing to kill any thread that happens to be idle when demand is low.

To support this more flexible mode of dynamic locations, we propose a second, complementary approach to
ensuring terminated threads do are not referenced---and thus do not cause deadlock.
Specifically, we propose tracking fractional permission in the type system~\todo{cite relevant stuff}.

\ethan{Things we need to discuss:
\begin{outline}{}
  \item What is fractional permission tracking?
  \item How is it used?
    \begin{lvl}
      \item Referencing location needs non-zero permission
      \item Killing location consumes full permission
      \item Connects to scoped locations by tracking permissions used in function types
    \end{lvl}
  \item How do we know what code to give a new location?
    \begin{lvl}
      \item This is a core research question of this sub-thrust
      \item Might tie into wait-until-called stuff in Thrust 3?
        If we give it wait-until-called code, it's obvious what it needs to do and how to use it.
    \end{lvl}
\end{outline}}

%\ethan{There are multiple problems to consider here.
%\begin{enumerate}[nosep]
%  \item How does the new location know what code to execute?
%  \item If you kill a location, how do you make sure you don't reference it again?
%    This comes in two different forms: regular instructions, and killing it twice.
%\end{enumerate}
%We propose two ways of handling this: scoping and linearity.
%We have preliminary work showing how to make scoping work, but it's missing some important features (e.g., thread pools).
%We will finish that and figure out to make linearity work.}

\subsubsection{Message Multi-Receives}
\label{sec:multi-receive}

\paragraph{Events}
\label{sec:events}

\ethan{Andrew, I think I might need to leave this one to you.}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "desc.tex"
%%% End:
