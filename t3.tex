%thrust3.tex
\subsection{Thrust 3: Choreographic Services}
\label{sec:t3}

While state-of-the-art choreographies excel at writing multiprocess programs, they are not able to express \emph{services},
where a \emph{provider} process waits for \emph{requests} from unknown \emph{clients}.
Once a request arrives, some code executes to satisfy the request, after which the provider returns to waiting for further requests.

It may seem surprising that process polymorphism does not immediately provide the ability to create services;
a process-polymorphic function can allow anyone to interact with a provider.
Using existing technology, however, the provider would have to know the identity of the client before it can receive a requests.
In a service, by contrast, a provider waits for a request from an unknown client.
The PI's joint work on first-class process polymorphism~\cite{SamuelsonHC25} could support a layer of indirection,
where the processing unit receives requests indirectly from a dispatcher without prior knowledge of the client's identity,
but this fails to address the underlying problem.
The dispatcher---which is fundamentally part of the service provider, not the client---would still need prior knowledge of the client's identity.

Adding the ability to write services immediately creates two problems:
multiple clients racing the call the same service,
and a mismatch between how services are structured and existing formulations of deadlock freedom.
To understand the first problem, imagine that~\Alice and~\Bob both make requests to the same service provider~\Server.
Without coordination between~\Alice and~\Bob, these requests can occur in either order---%%%
or even have the underlying communication substrate (e.g., the network in a distributed system) reorder them in flight---%%%
so \Server could correctly begin satisfying either request.
Once it has begun to serve one request, it must complete that request before processing the next.
This all happens despite the fact that the request appear in some particular order in the choreographic program.

Existing choreographic languages have some notion of \emph{out-of-order execution}
to model disjoint locations operating concurrently, but with services the problem is much more extreme.
Requests arriving in a different order will cause the \emph{same service provider} to satisfy those requests in a different order.
We believe that we can modify existing notions of out-of-order to fit choreographic services.
However, we propose to take a more radical approach that will provide strong results and more elegant proofs
for both existing out-of-order choreographic reasoning and for choreographic services.

To understand the mismatch between services and traditional deadlock freedom, imagine again that~\Alice and~\Bob both make requests to provider~\Server.
After both requests are satisfied, \Server{} will go back to waiting.
Intuitively this is not deadlock, despite the fact that a process waiting for a message that will never come is usually a sign of deadlock.
We propose to alleviate this discrepancy by adding distinguished \emph{service functions} which act like waits, but do not count as deadlocks.
Notably, a service provider waiting for a message that will never arrive \emph{while attempting to satisfy a request}
remains a deadlock, and we expect service functions to require some restrictions to avoid this scenario.

The rest of this subsection discusses these problems in more detail and proposes solutions.
We emphasize that solving the out-of-order execution problem using the radical approach we suggest here is not required.
It leads to a more elegant solution with stronger guarantees, but if it fails, we believe we can still provide a deadlock-free notion of choreographic services.

\subsubsection{A New Paradigm for Bisimulations}
\label{sec:new-parad-bisim}

Previous work on choreographic languages focused on proving that endpoint projection induced a \emph{bisimulation} between the choreographic code and the projected code.
Such bisimulations require that any action taken by the choreographic code must be possible in the projected code and vice versa.
Note that the projected code allows actions taken by disjoint processes to happen in any order; because of this, almost all choreographic languages allow for \emph{out-of-order execution}~\cite{Montesi23,HirschG22,Cruz-FilipeM17}.

These bisimulations are often used to prove deadlock freedom, as the result immediately transfers from standard safety results of single-threaded programs.
But such a bisimulation is far stronger than required, and in fact allows nearly any result about the program behavior to transfer from the choreography to the projected system.
Unfortunately, this execution bisimulation is nearly impossible to establish for functional choreographic languages.
Instead, existing work either weakens the choreographic language considerably (the approach the PIs have taken)~\cite{HirschG22,SamuelsonHC25} or applies fragile techniques that do not allow for basic additions to the language~\cite{CruzFilipeGLMP23}.
As functional choreographies acquire more and more features, it becomes paramount to develop better techniques
to transport analysis of important properties like deadlock freedom from the choreography, where analysis is simpler,
to its projections, which will actually execute.
%\ethan{
%  From AKH:
%  Core power of choreographies is that you can reason about the choreography rather than the distributed system.
%  We want whatever reasoning you have to transfer appropraitely.
%  We want to prove more than just deadlock freedom, ``such proofs'' below is everything.
%}

We observe that allowing such analysis transfer does not require the full power of this correspondence.
Instead, we can look at the possible \emph{traces}---lists of actions taken during a program run---of both the choreography and the projected system.
As long as these traces are \emph{equivalent up to rearranging actions involving disjoint sets of processes},
endpoint projection will preserve that semantics of the choreography,
giving a bisimulation between the choreographic and system \emph{traces}, even if not between their individual steps.
Indeed, this guarantee is sufficient to prove both deadlock freedom
and that the choreography accurately reflects each location's view of the system, and any properties that implies.
%This is enough to allow us to prove deadlock freedom and to transport other important properties from the choreographic language to its projection.
Thus, we do not need to allow out-of-order execution in the choreography at all.
Instead, we simply define its in-order trace-collecting execution, and then consider this trace up to equivalence.

We believe this scheme works perfectly for terminating languages, but nontermination introduces substantial complication.
Consider the choreography $\Alice.\programfont{loop} \seq \Bob.42 \ColSend \Cathy$.
In this program, \Alice{} enters an infinite loop ``and then'' \Bob{} sends 42 to \Cathy.
Using the above-proposed scheme with standard in-order trace-collecting semantics, the trace would consist only of \Alice in a loop.
In the projected system, however, \Bob is free to send 42 to \Cathy at any time.
This operation will never be reflected in the choreographic trace, so the traces are not equivalent, and the simple version of this approach falls apart.

To address this challenge, we propose to design a new in-order trace-collecting semantics that allows programs to ``continue after an infinite loop.''
Instead of traces being restricted to either finite length or length~$\omega$,
the traces collected by this semantics can be of larger (countable) \emph{ordinal length}.
So, in the above example, the trace could consist of~$\omega$ events from~\Alice in an infinite loop \emph{followed by} the message~$42$ going from~\Bob to~\Cathy.
Such a semantics will require considerable care to develop.
For instance, consider the choreography $\Alice.\programfont{loop} \seq \Alice.42 \ColSend \Cathy$---the above example but where~\Alice sends the message, not~\Bob.
In this program, \Cathy~is waiting for a message from a process that is in an infinite loop, meaning the message will never arrive and~\Cathy is also ``blocked.''
We must keep track of such ``blocked'' processes throughout the semantics.

\begin{goal}
  \label{goal:strong-epp}
  Develop a new formalization of traces that allows us to establish a bisimulation in the presence of local infinite loops.
  Use it to develop strong guarantees for process-polymorphic code.
\end{goal}

In addition to simplifying existing choreographic theorem and making it more robust,
this radical new approach provides a cleaner means to addressing the service-request-reordering concern discussed above.
When a provider starts and finishes satisfying a request, they emit dual trace events.
We then require these events to be well-bracketed in traces---every request start event must have a matching request end event---%%%
and consider traces equivalent if they reorder entire subtraces starting and ending with matching brackets.

\paragraph{Preliminary Work}
Both PIs have been collaborating on developing this new paradigm of bisimulation.
In particular, we have developed a trace-collecting semantics allowing ordinal-length traces, including reasoning about ``blocked'' processes as discussed above.
We are currently developing guarantees based on this semantics.

\subsubsection{Service Functions}
\label{sec:service-functions}

\newcommand{\Serv}{\programfont{serv}}

To provide a service, a process must wait indefinitely to receive a request from an unknown client.
This puts the concept of services in tension with the usual choreographic notion of deadlock freedom,
which requires that either some process can take a step no process has pending communications.
We will address this difference using a notion of \emph{service functions} which behave almost like normal polymorphic functions at the choreographic level.
For instance, we define a service as follows.
\[
  \ChorFont{service}~\Serv[\ChorFont{providers}\; \Alice](\alpha \ty \programfont{client},\, x \ty \alpha.\programfont{int}) \ChorDef C
\]
This declares a new service named~\Serv provided by~\Alice.
The projection for~\Alice will wait for a message from an unknown client~$\alpha$ to initiate a request.
When~\Serv is called in a choreography, we discover who the client is.
For instance, the call $\Serv\,(\Bob, \Bob.42)$, telling us that \Bob is the client of the function.
For~\Bob, this projects to sending a message to~\Alice, followed by participation in the body~$C$.
For~\Alice, the application projects to nothing;
\Alice~is already waiting to execute the appropriate portion of~$C$.

There are multiple intricacies to navigate.
First, there must be restrictions on if and when choreographic service providers can stop providing those services.
If they could do so at any time, a potential client may attempt to invoke a service that is no longer provided, leading to deadlock.
Similarly, any third party (non-client) involved in satisfying a service request must itself be a service.
Without knowledge of how many times the service will be used,
such a third party could either stop before the last request---causing the service to deadlock when they are not available to help process it---%%%
or expect more requests to arrive---becoming deadlocked waiting to process a service request that will never arrive.
It is likely that other similar restrictions will be required, as we will discover when designing the feature and proving it remains deadlock-free.

Significant complexity also comes from the fact that services can become races:
if two clients try to contact a service simultaneously, either request can get processed first.
The choreographic semantics will need to reason about these possible reorderings.
While adapting previous arguments for deadlock freedom and out-of-order executions should be sufficient,
it will add additional complexity only already complex constructions.
As described in Section~\ref{sec:new-parad-bisim}, our proposed formulation of traces outlined in Goal~\ref{goal:strong-epp}
provides a simpler and cleaner path forward.

Once we have a semantics for these service functions, we can treat a provider listening for a request as a value, rather than as a pending message receive.
Since such a provider is not deadlocked, this modeling choice resolves the tension between service waiting and deadlock freedom.
It is also similar to the approach taken to services in session types, which use replication to model services~\cite{DeYoungCPT09,CairesP10,Wadler12,LeBrunFD25},
and to coalgebraic data types, which wait to be observed before reacting~\cite{KozenS17}.
We plan to use techniques from each to develop our theory of service functions.

\begin{goal}
  \label{goal:wait-until-called}
  Develop a theory of service functions, service providers, and clients.
  Prove that it is deadlock free.
\end{goal}


\iffalse
\akh{New story idea:
  We want services.
  This requires (a) new formulation of DF and (b) new techniques for proving DF from choreos and (c) new out-of-order stuff.
  We could do (b) and (c) in an ad-hoc way as we have before, but we think something more radical will work better: strong epp.
  Note, even if more radical thing fails, we can still do more ad-hoc stuff.
  If we don't get services, strong epp still makes everything else better.
}

Choreographies are designed to give a guarantee of deadlock freedom.
In order to do so, they give some form of connection between the semantics of the choreographic program itself and the semantics of the projections.
Traditionally, this has been in the form of a bisimulation~\cite{Montesi13,Cruz-FilipeM17,HirschG22,Montesi23}, a particularly strong connection.
However, PI~Hirsch showed in Pirouette that for functional choreographies a bisimulation result requires implicit synchronization between all of the processes in a choreogrpahy~\cite{HirschG22}.
Chor$\lambda$ gets around this by using commuting conversions in the semantics of choreographies, which allows choreographic code to move above code that may run after it once projected~\cite{CruzFilipeGLMP23,CruzFilipeGLMP22}.
However, the combined work of both PIs later showed that this solution breaks in the presence of named recursive functions, a vital feature of functional programming~\cite{SamuelsonHC25}.
Instead, they used a single simulation (rather than a \emph{bi}simulation) to argue for deadlock freedom; however, this means that other properties of the choreographic programming language cannot be cleanly lifted to the projected programs, as they can with a bisimulation argument.

To see what goes wrong, consider the program
$\Alice.\programfont{loop} \seq \Bob.42 \ColSend \Cathy$.
In this program, \Alice{} goes into an infinite loop while \Bob{} sends $42$ to \Cathy{}.
While \Alice{}'s instructions come before \Bob{}'s message to \Cathy{} in the choreography, because they involve disjoint sets of processes they are implicitly concurrent in the choreography.
A bisimulation would require that any action of the projected programs can take place in the choreography.
In particular, this means that \Bob{}'s message to \Cathy{} can occur even while \Alice{} is in her infinite loop (or, in fact, \emph{before} \Alice{} enters her infinite loop).
Traditionally \emph{out-of-order execution} allows this to happen in the choreographic semantics~\cite{Montesi23}, but this turns out to be impossible in the functional case~\cite{HirschG22,CruzFilipeGLMP23,CruzFilipeGLMP22}.
This lead the PIs to weakening the guarantee in order to establish deadlock freedom in the presence of process polymorphism~\cite{SamuelsonHC25}.

Once a bisimulation is established, the traditional argument goes as follows:
``The choreographic program will never ``get stuck,'' so either it has computed a value or it can take another step.
But if that's true of the choreography, then it must be true of the projected program as well, thanks to the bisimulation.
Therefore, the projected program can never be stuck with a cycle of processes waiting on each other, avoiding deadlock.''
This is a powerful argument.
However, it does not work in the presence of \emph{services} which always come back to wait for more input from an unknown client.
These are not traditional values, nor are they evidence of a deadlock.
Therefore, we must reformulate our notion of deadlock freedom as well as our proof techniques.

We propose to fix both these problems via (1) a new formalization of deadlock freedom and (2) a new paradigm for reestablishing bisimulations in the presence of infinite loops.
The new formalization of deadlock freedom will allow us to leverage process polymorphism to build choreographies in which some processes are services.
The new paradigm for reestablishing bisimulations will allow us to give strong guarantees to the projections of choreographic programs, even in the presence of process polymorphism.

\subsubsection{A New Formalization of Deadlock Freedom}
\label{sec:new-form-deadl}

Current formalizations of deadlock freedom say that no process is allowed to be waiting for a message.
However, a process that is providing a service will always be waiting for a message when it is not in the process of serving a request.
Thus, according to the standard formalization of deadlock freedom, no process that provides a service can be deadlock free.
This contradicts intuition and prevents choreographies from maintaining their goal of deadlock freedom by construction while allowing the development of services.
We plan to combat that contradiction by developing a new formalization of deadlock freedom.

We envision a choreographic service as a type of choreographic function in which some (concrete) processes \emph{provide} a service, while any other process(es) can act as (a) client(s).
The processes that provide a service wait to receive a \emph{request} from the clients, which causes the body of the function to run.
Importantly, while a service appears like any other function in the choreography, the processes providing the service do not get any information about when they are run.
Endpoint projection instead allows them to wait for a message signaling that some (statically unknown) client is requesting their service.
This message wait must be considered a value, rather than being considered a sign of deadlock, even when no client will ever again request the service.

This requires some care.
First, processes that provide a service must always eventually come to provide the same set of services (assuming that they are not in an infinite loop).
Otherwise, a process that is requesting a service may wait forever for the service to come back online, even though the provider has simply decided to take that service offline.
We plan to use ideas from coalgebraic data types and higher-order functions in order to ensure this.

Second, any third party---neither the provider nor the client of the service---mentioned in the body of the service function must also provide a service, and they may only be mentioned by calling their service.
Without this restriction, that third party may not be aware that the service is required, and cause deadlock.
We will use static analysis, likely embedded in the type system, to guarantee that this invariant is maintained.

Another wrinkle comes in the form of an ordering requirement.
Consider a choreography in which \Alice{} provides a service which is called twice, once by \Bob{} and once by \Cathy{} in that order.
After projection, this will appear as \Alice{} waiting for a request from an unknown client, while both \Bob{} and \Cathy{} attempt to make such a request.
This is a race, and so \Alice{} may start to process either request first.
Compare this situation to that of a standard choreographic function, which would force \Alice{} to enter the function with \Bob{} \emph{before} entering it with \Cathy{}.
We believe that this can be solved even with the fragile out-of-order evaluation procedures of previous work~\cite{CruzFilipeGLMP23,Montesi23,HirschG22}.
However, completing Goal~\ref{goal:strong-epp} will allow us to solve the problem more elegantly.

\begin{goal}
  \label{goal:wait-until-called}
  Develop a new formalization of deadlock freedom that allows for a wait-until-called paradigm.
  Use it to prove that a version of choreographies with services is deadlock free.
\end{goal}

\subsubsection{A New Paradigm for Bisimulations}
\label{sec:new-parad-bisim}

Recall that bisimulations require that any action taken by a choreographic program can be taken by its endpoint projection and vice-versa.
Since choreographies impose a textual ordering on actions between disjoint sets of processes, traditionally they allow for \emph{out-of-order execution} in their semantics in order to provide a bisimulation.
In the presence of named recursive functions this turns out to be impossible~\cite{SamuelsonHC25}, causing previous work to reach for weakening either the language or the guarantees~\cite{HirschG22,CruzFilipeGLMP22,SamuelsonHC25}.
We propose a new way to build bisimulations that does not require out-of-order execution and works in the presence of general named recursive functions.

Our key insight is that processes in a choreography always take the same actions in the same order, and actions can only be reordered between disjoint sets of processes.
If we look at a \emph{trace} of actions in a choreography, that trace will always contain the same actions in the same order as the projected code takes.
This ordering requirement will hold even if we arrange the actions of the trace, so long as we do not reorder any process's actions relative to each other.
These considerations lead to the following idea: run the choreography in-order, collecting a trace.
However, we consider that trace up to the equivalence generated by reordering the actions of disjoint processes.
We can then ``project'' those traces to a trace for every process; equivalent choreographic traces will project to equal traces for a given process.
A bisimulation then means that any choreographic trace corresponds to the traces of a possible run of the projected processes and vice-versa.
This is weaker in one sense to the more-traditional bisimulation, but because the trace contains all of the information about the semantics which we rely upon when making guarantees, that weakness is irrelevant.

The paradigm described above is straightforward for terminating programs.
Possible nontermination, however, leads to several wrinkles that must be considered.
First, if a process goes into an infinite loop in the choreography, no other events will be collected in the trace, even from other processes.
We plan to solve this by allowing for traces to be \emph{ordinal-length}, allowing for more trace elements to come ``after'' an infinite loop in the trace.
Second, if \Alice{} goes into an infinite loop, then \Bob{} waits for a message from \Alice, he will be stuck waiting for her.
Thus, no more of \Bob{}'s actions should appear in the trace.
We plan to solve this by keeping track of a set of ``blocked'' processes that grows over time
Not only do blocked processes take no actions in a choreography, but attempts to communicate with a blocked process will cause unblocked processes to become blocked.

Once we have this theory of traces and the services described above, we can easily describe the race condition considered above.
Simply put, when a service provider begins to process a request, they emit a trace event describing the clients of that request; once they finish processing the request, they emit a dual trace event.
We require that traces are well bracketed, and then consider traces equivalent if they rearrange entire bracketed subtraces.
This allows us to consider both the world in which \Alice{} serves \Bob{}'s request first and the world in which \Alice{} serves \Cathy{}'s request first equally.

\begin{goal}
  \label{goal:strong-epp}
  Develop a new formalization of traces that allows us to establish a bisimulation in the presence of local infinite loops.
  Use it to develop strong guarantees for process-polymorphic code.
\end{goal}
\fi


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "desc"
%%% End:
