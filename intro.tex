%!TEX root = desc.tex
\maketitle

\section{Introduction}
\label{sec:intro}

\begin{outline}{Introduction Outline}
  \item Programming concurrent and distributed systems correctly is hard, but choreographies can help!
    \begin{lvl}
      \item A major promise of choreographies is that the implementation of a protocol
        can directly mirror the structure of a protocol specification.
      \item This idea simplifies system building, helps with rapid prototyping, and simplifies checking that the implementation matches the spec.
    \end{lvl}

    \item State-of-the-art choreographies are missing critical features needed to accomplish this goal.
    \begin{lvl}
      \item Common systems with complex protocols include
        web servers, microservice architectures, distributed consensus protocols (e.g., Paxos), and thread pools.
        \ethan{I'm not sure we want to talk about Paxos if we're not doing asynchrony.}
      \item None of these can be implemented with current choreographic technology for a fundamental reason:
        every message must be sent and received in a pre-determined order by a pre-determined set of locations,
        and all parties must know each other's identities \emph{in advance}.
      \item The above protocols violate these assumptions in multiple ways.
        \begin{lvl}
          \item They wait for messages that may arrive at any time (or not at all) without knowing when.
          \item Messages may come from any client, and the recipient only learns the client's identity with the message arrives.
          \item They execute in response to one or more messages arriving, and may do so an unbounded number of times.
          \item Nodes/threads/processes/etc are often spawned dynamically in response to requests
            with identities that cannot be known in advance.
            \ethan{We've partially solved this one already!}
%          \item Web servers wait for a message from any (unknown) client.
%          \item Microservices are similar, but may only accept messages from a specific set of clients.
%          \item Consensus protocols wait for messages to arrive from any subset of a known set of peer nodes.
%          \item Thread pools spawn and kill threads to load balance effectively.
%          \item All these protocols wait for one or more messages
%            that may or may not ever arrive and execute in response.
        \end{lvl}
    \end{lvl}

  \item We propose \emph{choreographic service architectures}, new features to support these types of applications.
    \begin{lvl}
      \item Wait-until-called paradigm
        \begin{lvl}
          \item Instead of executing a specific program, just wait until a client invokes the service.
          \item Supports web servers and microservices.
        \end{lvl}

      \item General multi-receives
        \begin{lvl}
          \item The receive specifies a set of senders they are listening for (or just accept from anyone)
            and the number of messages they are waiting on.
          \item When enough messages from the specified senders arrive, the multi-receive returns allowing them to execute.
          \item Multi-receive explicitly provides the recipient with the list of messages that arrived in order and the identity of the sender of each.
        \end{lvl}

      \item Spawning and killing threads
        \begin{lvl}
          \item We have preliminary work on a fork-join paradigm where new threads only exist in a bounded scope.
          \item Protocols like thread pools need an unbounded scope, but that is challenging to know who is alive and who isn't.
        \end{lvl}
    \end{lvl}
  \ethan{%
    I was having real trouble with arguing for event-driven promises.
    Feel free to add that in.
    Also, interrupts feel totally bizarre in this setting (unless they're implemented as a spawned thread waiting)
    because the choreography no longer specifies a bunch of in-order programs that run as a concurrent system;
    individual locations are now out-of-order based on the interrupts.
    I wasn't sure what to do with that.
  }
\end{outline}
\hrule
\vspace{0.5em}

Nearly every major computer system now relies on substantial concurrency for performance and scalability,
yet designing and implementing correct concurrent systems is famously challenging.
The new paradigm of \emph{choreographic programming}~\citep{Montesi13,Montesi23} offers to simplify development and analysis of such systems.
Instead of writing separate programs for each thread, process, or node, within a system---forcing developers to analyze the complex interplay of these programs---% DO NOT DELETE, COMMENT IS IMPORTANT FOR SPACING
choreographies mirror more informal protocol specifications with a single top-level program
describing both the local operations of each piece of the system and how they interact.

The promise of choreographic programming is twofold.
First, the implementation of a protocol can directly mirror its specification.
%with one program describing the behaviors and interactions of every part of the system.
\ethan{I think a small example here would be useful.}
Second, by combining different programs, global control flows become more visible
and drastically simplify analysis of important properties like deadlock freedom~\citep{CarboneM13}.
In this way, choreographies aim to simply system building, help with rapid prototyping,
and simplify both checking that the implementation matches the specification
and analyzing important system properties.

While existing choreographic theory has advanced rapidly since its introduction just over a decade ago~\citep{CarboneM13,HirschG22,CruzFilipeGLMP22,CruzFilipeGLMP23,BatesK+25,SamuelsonHC25}\ethan{what else?},
existing work still relies on the following extremely strong assumptions:
\begin{enumerate}
  \item\label{li:assume:static-locs}
    There must be a pre-determined set of locations.
  \item\label{li:assume:known-order}
    Those locations must send and receive messages in a pre-determined order.
  \item\label{li:assume:known-endpoints}
    The senders and recipients of each message must be know to all relevant parties in advance.
\end{enumerate}
%there must be (1)~a pre-determined set of locations
%who (2)~send and receive messages in a pre-determined order,
%and (3)~all parties must know each others' identities in advance.

These assumptions rule out numerous common distributed system structures,
including client-server models, like web servers or microservice architectures, thread pools, and consensus protocols, as each violates them in multiple ways.
Processing requests often involves spawning new threads, violating assumption~(\ref{li:assume:static-locs}).
These systems all require parties to wait for messages without knowing when or if they will arrive,
either from clients, other consensus nodes, or a pool manager, violating assumption~(\ref{li:assume:known-order}).
Finally, messages may come from many different senders, and the recipient only learns their identity when the message arrives,
violating assumption~(\ref{li:assume:known-endpoints}).

We propose to design, analyze, and implement new features in choreographic languages that eliminate the need for these assumptions,
yet still guarantee important properties like deadlock freedom and support simplified programming and analysis.
\ethan{Advertise developing new theory?}
These innovations will allow us to build the service-based architectures mentioned above as choreographies.

\subsection{Intellectual Merit}
We propose to support three new features currently lacking in choreographies.
\ethan{Should these just be the thrusts?}

\begin{itemize}[leftmargin=*]
  \item \textbf{Spawning Threads:}
    The first feature is the ability to spawn and kill new computational units---threads, processes, nodes, etc---% DO NOT DELETE, COMMENT IS IMPORTANT FOR SPACING
    a core feature of many concurrent systems.
    A few early choreographic works recognized its importance~\citep{CarboneM13,CruzFilipeM16a},
    but those works lacked critical features for realistic programming, like higher-order operations,
    and required threads to be spawned only to execute specific pre-defined operations.

    We propose a much more general structure, where there is little distinction between
    and existing execution thread and a newly-spawned one and threads may be killed when they are no longer needed.
    Moreover, we will integrate this dynamic thread management with a host of modern choreographic advances,
    including higher-order functions and process polymorphism.

  \item \textbf{Wait-Until-Called Paradigm:}
    The second core feature is to allow choreographic specification of services
    that process requests when called by any client and then wait for another request.
    These services cannot be implemented with existing choreographic tools,
    as they require services to accept messages from many different clients---potentially even unknown ones---% DO NOT DELETE, COMMENT IS IMPORTANT FOR SPACING
    without knowing who will make a request before it arrives.

    In addition to requiring message recipients to only learn the sender's identity when the message arrives,
    this important paradigm will also require a fundamentally new notion of deadlock freedom.
    Existing choreographies define deadlock freedom to mean either every location has terminated or some location can execute.
    With wait-until-called services, however, a service may be safely waiting for a new request when all others have terminated without indicating any problem.
    We propose to develop new choreographic theory to develop and analyze systems that include such services.

  \item \textbf{Message Multi-Receives:}
    While existing choreographies allow for multi-sends---broadcast messages with multiple recipients sent in no particular order---% DO NOT DELETE, COMMENT IS IMPORTANT FOR SPACING
    they do not allow \emph{multi-receives}, where one recipient waits on messages from multiple senders without a pre-specified order.
    We propose to design a general and powerful version of this feature
    to allow recipients to wait on only a fixed number of messages from a potentially larger number of senders,
    and know which messages arrived and in which order once the threshold is reached.
    This is precisely the language primitive needed to implement redundant protocols like distributed consensus
    that are designed to be robust to failures where messages may not arrive.
\end{itemize}

Importantly, proper design of each of these features will rely heavily
on recent work by the PIs on first-class process polymorphism~\citep{SamuelsonHC25}.
This work shows how to choreographies can support dynamically computation of location names,
which is critical for writing code that interacts with newly spawned threads
or receives messages from unknown clients and must respond to them.

\subsection{Motivation ...}
\label{sec:motivation}


\subsection{Research Team}

\subparagraph{Ethan Cecchetti} is an expert...

\subparagraph{Andrew K. Hirsch} is an expert in choreographic programming...

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "desc"
%%% End:
