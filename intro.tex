%!TEX root = desc.tex
\maketitle

\section{Project Description}
\label{sec:intro}

Nearly every major computer system now relies on substantial concurrency for performance and scalability,
yet designing and implementing correct concurrent systems is famously challenging.
The new paradigm of \emph{choreographic programming}~\citep{Montesi13,Montesi23} promises to simplify development and analysis of such systems.
Instead of writing separate programs for each system component---forcing developers to analyze the interplay of these programs---% DO NOT DELETE, COMMENT IS IMPORTANT FOR SPACING
choreographies mirror more informal protocol specifications with a single top-level program
describing both the local operations of each component---which we call \emph{processes}, though they may be threads, processes, or even entire nodes---and how they interact.

The promise of choreographic programming is twofold.
First, the implementation of a protocol can directly mirror its specification.
For instance, a protocol that includes ``Alice sends message~$m$ to Bob, who forwards it to Cathy''
could be written as the choreography $(\text{Alice}.m \sendsto \text{Bob}) \sendsto \text{Cathy}$.
A compiler can then automatically generate three separate pieces of code, one for each of Alice, Bob, and Cathy,
with separate send and receive instructions.
Contrast this with traditional programming techniques, which require developers to write the three separate pieces of code directly.
Second, the existence of a global program makes global control flows more visible.
This structure not only provides deadlock freedom by construction~\cite{CarboneM13}, but also drastically simplifies other program analyses.
In this way, choreographies aim to ease system building, help with rapid prototyping,
and simplify both checking that implementations matches specifications
and analyzing important system properties.

Rapid progress in choreographic theory in the past few years~\citep[e.g.,][]{HirschG22,CruzFilipeGLMP22,CruzFilipeGLMP23,BatesK+25,SamuelsonHC25}
has brought this promise closer into view, but substantial work remains.
In particular, current choreographic theory relies on three extremely strong assumptions
that each rule out many common architectures, including thread pools, consensus protocols, and client-server models like web servers or microservice architectures:
\begin{enumerate}
  \item\label{li:assume:static-locs}
    There must be a pre-determined set of processes.
  \item\label{li:assume:known-order}
    Those processes must send and receive messages in a pre-determined order.
  \item\label{li:assume:known-endpoints}
    The senders and recipients of each message must be known to all relevant parties in advance.
\end{enumerate}

A recent result by both PIs showing how to safely enable first-class process polymorphism~\citep{SamuelsonHC25} opens critical new avenues for research alleviating those assumptions.
Choreographies can now dynamically compute and communicate which process(es) will perform any given action,
allowing run-time flexibility and increased code reuse.
On its own, this result is an important addition to the choreographic toolbox,
but its real power lies in creating a foundation to accelerate advances in choreographic technology.

\emph{We propose to leverage process polymorphism to develop substantial new theory and implementation techniques, bringing the choreographic programming paradigm closer to its promise.}
Guiding this work will be the goal of enabling choreographies to specify common concurrent and distributed systems.
This is not possible currently, as many systems violate the assumptions above.
Processing requests often involves spawning new threads, violating assumption~(\ref{li:assume:static-locs}).
Microserves must wait for requests without knowing when or if they will arrive, violating assumption~(\ref{li:assume:known-order}).
Finally, consensus nodes simultaneously wait for messages from many senders
and only learn who sent valid messages after they arrive,
violating assumption~(\ref{li:assume:known-endpoints}).

Notably, the PIs have a longstanding and fruitful collaboration.
They have worked together not only on process polymorphism~\cite{SamuelsonHC25}, but on information-flow control~\cite{SilverHCHZ23,HirschC21} and authorization logic~\cite{HirschACAT20}.
They have additionally developed preliminary work for this grant together, as described below; PI~Hirsch has also developed preliminary work in the form of a choreographic compiler as described below.

\subsection{Intellectual Merit}

To alleviate the need for the assumptions listed above and allow choreographic programming to achieve its promise in practical systems,
we plan to pursue the following research, organized into three synergistic thrusts.

\paragraph{\hyperref[sec:t1]{Thrust 1 (Polymorphism-Enabled Features)}}
Directly building on the power of first-class process polymorphism, we will develop features key to removing the restrictive assumptions.
First, we will give choreographic programs the ability do \emph{dynamically spawn new threads} that can interact with other participants in a first-class way.
Second, we will develop a \emph{multi-receive} primitive allowing a process to wait for messages from any number of senders, receiving those messages in any order.
In particular, we plan to design a version of this feature that allows programmers to specify exactly what pattern of messages a program must receive before continuing,
or even multiple patterns leading to different computations.

\paragraph{\hyperref[sec:t2]{Thrust 2 (Improved Compilation for Process Polymorphism)}}
The powerful features enabled by process polymorphism rely on it having an efficient implementation,
but current theory requires a compilation step that can result in a single process's code being exponentially larger than the choreographic code.
In this thrust we will examine when and how it is possible to optimize this process, allowing for smaller and more performant concurrent code.
To validate our optimizations, we will also develop a benchmark of process-polymorphic programs,
also helping speed the development of further process polymorphism technology.

\paragraph{\hyperref[sec:t3]{Thrust 3 (Choreographic Services)}}
Finally, we will add the ability for choreographies to express services, where a service provider processes requests from clients
with no advanced knowledge of when or if a request will arrive or which client(s) might make them.
Such services conflict with existing formulations of deadlock freedom and significantly complicate the associated proof techniques.
We thus propose to develop a new paradigm for relating choreographies to the concurrent systems they specify.
It will support more powerful and expressive choreographic language features, like services,
while allowing analysis of important properties like deadlock freedom to transfer from the choreographic source code to the compiled system.

\smallskip

Each trust individually proposes a valuable advancement to the theory and practice of choreographic programming.
Their combination, however, is substantially more powerful than each thrust on their own.
Improving performance of process polymorphism (\hyperref[sec:t2]{Thrust 2}) makes all features relying on it more practical and effective.
Similarly, services (\hyperref[sec:t3]{Thrust 3}) that can spawn new threads and condition request processing on multi-receive functionality (\hyperref[sec:t1]{Thrust 1})
opens choreographic programming to vast new categories of applications.

\subsection{Research Team}

As stated above, the PIs have a longstanding and fruitful collaboration.
They have weekly remote meetings, and visit in person at least annually.
Moreover, they each bring unique skills to the table which have proven synergistic many times in the past.

\subparagraph{Ethan Cecchetti} is an expert in applying programming-language theory to systems.
He is a coinventor of first-class process polymorphism for choreographies~\citep{SamuelsonHC25}.
He has established links between foundational frameworks in programming languages and cryptography~\citep{KuennemannPC24,PatrignaniKWC24},
developed foundational theory around information-flow control~\citep{HirschACAT20,HirschC21,SilverHCHZ23},
and shown how to generalize standard language-based conditions to more nuanced contexts~\citep{CecchettiMA17,CecchettiYNM21,Cecchetti25}.
Finally, he has used applied cryptographic tools to design protocols for real-world decentralized systems~\citep{ZhangCCJS16,CecchettiZJKJS17,CrooksBCHAA18,CecchettiFMJ19}.

\subparagraph{Andrew K. Hirsch} is an expert in the theory of programming languages.
In particular, he is one of the inventors of functional choreographic programming~\cite{HirschG22} and process polymorphism~\cite{GraversenHM24}, and he has developed considerable expertise in the area~\cite{SamuelsonHC25,GraversenHM24,HirschG22,BohosianH25}.
He is also an expert in information-flow control~\cite{SilverHCHZ23,MenzHLG23,HirschC21,HirschACAT20}, the theory of effects~\cite{SilverHCHZ23,HirschC21,HirschT18}, and authorization logic~\cite{HirschACAT20,HirschC13}.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "desc"
%%% End:
