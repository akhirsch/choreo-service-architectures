%!TEX root = desc.tex
\maketitle

\section{Introduction}
\label{sec:intro}

\begin{outline}{Introduction Outline}
  \item Programming concurrent and distributed systems correctly is hard, but choreographies can help!
    \begin{lvl}
      \item A major promise of choreographies is that the implementation of a protocol
        can directly mirror the structure of a protocol specification.
      \item This idea simplifies system building, helps with rapid prototyping, and simplifies checking that the implementation matches the spec.
    \end{lvl}

    \item State-of-the-art choreographies are missing critical features needed to accomplish this goal.
    \begin{lvl}
      \item Common systems with complex protocols include
        web servers, microservice architectures, distributed consensus protocols (e.g., Paxos), and thread pools.
        \ethan{I'm not sure we want to talk about Paxos if we're not doing asynchrony.}
      \item None of these can be implemented with current choreographic technology for a fundamental reason:
        every message must be sent and received in a pre-determined order by a pre-determined set of locations,
        and all parties must know each other's identities \emph{in advance}.
      \item The above protocols violate these assumptions in multiple ways.
        \begin{lvl}
          \item They wait for messages that may arrive at any time (or not at all) without knowing when.
          \item Messages may come from any client, and the recipient only learns the client's identity with the message arrives.
          \item They execute in response to one or more messages arriving, and may do so an unbounded number of times.
          \item Nodes/threads/processes/etc are often spawned dynamically in response to requests
            with identities that cannot be known in advance.
            \ethan{We've partially solved this one already!}
%          \item Web servers wait for a message from any (unknown) client.
%          \item Microservices are similar, but may only accept messages from a specific set of clients.
%          \item Consensus protocols wait for messages to arrive from any subset of a known set of peer nodes.
%          \item Thread pools spawn and kill threads to load balance effectively.
%          \item All these protocols wait for one or more messages
%            that may or may not ever arrive and execute in response.
        \end{lvl}
    \end{lvl}

  \item We propose \emph{choreographic service architectures}, new features to support these types of applications.
    \begin{lvl}
      \item Wait-until-called paradigm
        \begin{lvl}
          \item Instead of executing a specific program, just wait until a client invokes the service.
          \item Supports web servers and microservices.
        \end{lvl}

      \item General multi-receives
        \begin{lvl}
          \item The receive specifies a set of senders they are listening for (or just accept from anyone)
            and the number of messages they are waiting on.
          \item When enough messages from the specified senders arrive, the multi-receive returns allowing them to execute.
          \item Multi-receive explicitly provides the recipient with the list of messages that arrived in order and the identity of the sender of each.
        \end{lvl}

      \item Spawning and killing threads
        \begin{lvl}
          \item We have preliminary work on a fork-join paradigm where new threads only exist in a bounded scope.
          \item Protocols like thread pools need an unbounded scope, but that is challenging to know who is alive and who isn't.
        \end{lvl}
    \end{lvl}
  \ethan{%
    I was having real trouble with arguing for event-driven promises.
    Feel free to add that in.
    Also, interrupts feel totally bizarre in this setting (unless they're implemented as a spawned thread waiting)
    because the choreography no longer specifies a bunch of in-order programs that run as a concurrent system;
    individual locations are now out-of-order based on the interrupts.
    I wasn't sure what to do with that.
  }
\end{outline}
\hrule
\vspace{0.5em}

\noindent\textbf{AKH Thoughts}
I think we may want to have thrusts similar to the following:
\begin{outline}[2]{}
\item \textbf{New Features}
  \begin{lvl}
  \item Spawning
  \item Multireceive 
  \item Events
  \end{lvl}
\item \textbf{Compilation Techniques}
  \begin{lvl}
  \item Avoid exponential Code Blowup (don't duplicate code if you know you must be in one branch!)
  \item Create a benchmark and discuss potential runtime blowup coming from code blowup
  \end{lvl}
\item \textbf{New Theory}
  \begin{lvl}
  \item Wait-Until-Called
  \item Strong EPP \ethan{connection: even harder to argue for correctness of EPP once you have process polymorphism if you don't have Strong EPP done.}
  \end{lvl}
\end{outline}

If we do this, we may want to change the name of the grant to something like ``Empowering Process Polymorphism.''

\vspace{0.5em}
\hrule
\vspace{0.5em}

Nearly every major computer system now relies on substantial concurrency for performance and scalability,
yet designing and implementing correct concurrent systems is famously challenging.
The new paradigm of \emph{choreographic programming}~\citep{Montesi13,Montesi23} offers to simplify development and analysis of such systems.
Instead of writing separate programs for each thread, process, or node, within a system---forcing developers to analyze the complex interplay of these programs---% DO NOT DELETE, COMMENT IS IMPORTANT FOR SPACING
choreographies mirror more informal protocol specifications with a single top-level program
describing both the local operations of each piece of the system and how they interact.

The promise of choreographic programming is twofold.
First, the implementation of a protocol can directly mirror its specification.
%with one program describing the behaviors and interactions of every part of the system.
\ethan{I think a small example here would be useful.}
Second, by combining different programs, global control flows become more visible
and drastically simplify analysis of important properties like deadlock freedom~\citep{CarboneM13}.
In this way, choreographies aim to simply system building, help with rapid prototyping,
and simplify both checking that the implementation matches the specification
and analyzing important system properties.
Rapid progress in choreography theory in the past few years~\citep[e.g.,][]{HirschG22,CruzFilipeGLMP22,CruzFilipeGLMP23,BatesK+25,SamuelsonHC25}
has brought this promise closer into view, but substantial work remains.

%\akh{This feels weak.
%  In particular, I can imagine exactly this intro as a reasonable POPL/OOPSLA paper.
%  We want to demonstrate that this is worth 3-6 of those papers!
%}
%\akh{This also has a seperability problem: right now, this reads as ``we need to solve all of these problems for any of them to be worth it.''
%  We instead want to say ``solving any one of these problems will be helpful, but solving them together is synergistic.''
%}

Notably, a recent result by the PIs showing how to safely enable first-class location polymorphism~\citep{SamuelsonHC25} opens critical new avenues for research.
Choreographies can now dynamically compute and communicate which location(s) will perform any given action,
allowing run-time flexibility and increased code reuse.
On its own, this result is an important addition to the choreographic toolbox,
but its real power lies in creating a foundation to accelerate advances in choreographic technology.

We propose to \emph{leverage process polymorphism to develop substantial new theory to realize the promise of the choreographic programming paradigm}.
Guiding this work will be the goal of enabling choreographies to specify common concurrent and distributed systems as choreographies.
Existing choreographic theory relies on three extremely strong assumptions
that each rule out many of these common architectures, including thread pools, consensus protocols, and client-server models like web servers or microservice architectures.
\begin{enumerate}
  \item\label{li:assume:static-locs}
    There must be a pre-determined set of locations.
  \item\label{li:assume:known-order}
    Those locations must send and receive messages in a pre-determined order.
  \item\label{li:assume:known-endpoints}
    The senders and recipients of each message must be know to all relevant parties in advance.
\end{enumerate}
Processing requests often involves spawning new threads, violating assumption~(\ref{li:assume:static-locs}).
Microserves must wait for requests without knowing when or if they will arrive, violating assumption~(\ref{li:assume:known-order}).
Finally, consensus nodes may simultaneously wait for messages from many senders
and only learn who sent valid messages after they arrive,
violating assumption~(\ref{li:assume:known-endpoints}).

Importantly, these assumptions are not fundamental to choreographies,
but rather constraints needed to enforce deadlock freedom in the absence of process polymorphism with first-class location names.
A newly spawned thread must have a name that existing computations can refer to.
When messages can be received out of order or the recipient is unaware of who a message might come from,
the message must identify its sender, requiring a first-class representation of location names.
We propose to develop new tools and theory based on our recent work on first-class process polymorphism~\citep{SamuelsonHC25}
to remove these assumptions and enable choreographic implementations of far more systems.

\ethan{Something here about efficiency and need for new theory like wait-until-called deadlock freedom.}

\ethan{Do we want to add a note about preliminary work to the intro?}

\subsection{Intellectual Merit}

We propose to accomplish the above goals through three independent but highly synergistic thrusts.
\begin{itemize}
  \item \textit{Thrust 1 (Polymorphism-Enabled Features):}
  \item \textit{Thrust 2 (Improved Compilation for Process Polymorphism):}
  \item \textit{Thrust 3 (\ethan{Need a good name for the theory thrust}):}
\end{itemize}


%These assumptions rule out numerous common distributed system structures,
%including client-server models, like web servers or microservice architectures, thread pools, and consensus protocols, as each violates them in multiple ways.
%Processing requests often involves spawning new threads, violating assumption~(\ref{li:assume:static-locs}).
%These systems all require parties to wait for messages without knowing when or if they will arrive,
%either from clients, other consensus nodes, or a pool manager, violating assumption~(\ref{li:assume:known-order}).
%Finally, messages may come from many different senders, and the recipient only learns their identity when the message arrives,
%violating assumption~(\ref{li:assume:known-endpoints}).

\iffalse
We propose to design, analyze, and implement new features in choreographic languages that eliminate the need for these assumptions,
yet still guarantee important properties like deadlock freedom and support simplified programming and analysis.
\ethan{Advertise developing new theory?}
These innovations will allow us to build the service-based architectures mentioned above as choreographies.

\subsection{Intellectual Merit}
We propose to support three new features currently lacking in choreographies.
\ethan{Should these just be the thrusts?}

\begin{itemize}[leftmargin=*]
\item \textbf{Spawning Threads:}
    \akh{Is this \emph{just} our POPL submission? What else needs to be done, and why?}

    The first feature is the ability to spawn and kill new computational units---threads, processes, nodes, etc---% DO NOT DELETE, COMMENT IS IMPORTANT FOR SPACING
    a core feature of many concurrent systems.
    A few early choreographic works recognized its importance~\citep{CarboneM13,CruzFilipeM16a},
    but those works lacked critical features for realistic programming, like higher-order operations,
    and required threads to be spawned only to execute specific pre-defined operations.

    We propose a much more general structure, where there is little distinction between
    and existing execution thread and a newly-spawned one and threads may be killed when they are no longer needed.
    Moreover, we will integrate this dynamic thread management with a host of modern choreographic advances,
    including higher-order functions and process polymorphism.

  \item \textbf{Wait-Until-Called Paradigm:}
    The second core feature is to allow choreographic specification of services
    that process requests when called by any client and then wait for another request.
    These services cannot be implemented with existing choreographic tools,
    as they require services to accept messages from many different clients---potentially even unknown ones---% DO NOT DELETE, COMMENT IS IMPORTANT FOR SPACING
    without knowing who will make a request before it arrives.

    In addition to requiring message recipients to only learn the sender's identity when the message arrives,
    this important paradigm will also require a fundamentally new notion of deadlock freedom.
    Existing choreographies define deadlock freedom to mean either every location has terminated or some location can execute.
    With wait-until-called services, however, a service may be safely waiting for a new request when all others have terminated without indicating any problem.
    We propose to develop new choreographic theory to develop and analyze systems that include such services.

  \item \textbf{Message Multi-Receives:}
    While existing choreographies allow for multi-sends---broadcast messages with multiple recipients sent in no particular order---% DO NOT DELETE, COMMENT IS IMPORTANT FOR SPACING
    they do not allow \emph{multi-receives}, where one recipient waits on messages from multiple senders without a pre-specified order.
    We propose to design a general and powerful version of this feature
    to allow recipients to wait on only a fixed number of messages from a potentially larger number of senders,
    and know which messages arrived and in which order once the threshold is reached.
    This is precisely the language primitive needed to implement redundant protocols like distributed consensus
    that are designed to be robust to failures where messages may not arrive.
\end{itemize}

Importantly, proper design of each of these features will rely heavily
on recent work by the PIs on first-class process polymorphism~\citep{SamuelsonHC25}.
This work shows how to choreographies can support dynamically computation of location names,
which is critical for writing code that interacts with newly spawned threads
or receives messages from unknown clients and must respond to them.
\fi

%\subsection{Motivation ...}
%\label{sec:motivation}


\subsection{Research Team}

\ethan{We have a longstanding collaboration. Drive that home.}

\subparagraph{Ethan Cecchetti} is an expert...

\subparagraph{Andrew K. Hirsch} is an expert in choreographic programming...

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "desc"
%%% End:
